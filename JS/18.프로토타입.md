## 프로토타입

- C++, Java와 같은 클래스 기반 객체지향 프로그래밍 언어다.
- 자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어다.
- 원시 타입의 값을 제외한 나머지 값들(함수, 배열, 정규표현식)은 모두 객체이다.



> 클래스 (class)

자바스크립트의 클래스는 사실 함수라고 볼수 있으며, 기존 프로토타입 기반 패턴의 **문법적 설탕**이라고 볼 수 있다.
그렇다면 클래스와 생성자함수 모두 프로토타입 기반의 인스턴스를 생성하지만, 동일하게 동작하지는 않는다.
클래스는 생성자 함수보다 엄격하며 추가적인 기능을 더 지원한다. 



### 객체 지향 프로그래밍 (Object Oriented Programing)

- 여러개의 독립적 단위, 객체들의 집합으로 표현하려는 프로그래밍 패러다임을 말한다.
- 다양한 속성중에서 프로그램에 필요한 속성만을 간추려 표현하는것을 **추상화**라 한다.



### 상속

- 객체지향 프로그램의 핵심 개념으로 객체의 프로퍼티 또는 메소드를 다른 객체가 상속받아 그대로 사용할 수 있는것을 말한다.
- 자바스크립트는 프로토타입을 기반으로 상속을 구현하며, 불필요한 중복을 줄일 수 있다.

```
// 생성자 함수
function Circle(radius) {
  this.radius = radius;
  this.getArea = function () {
    // Math.PI는 원주율을 나타내는 상수이다.
    // Math.pow는 첫번째 인수를 두번째 인수로 거듭제곱한 값을 반환한다.
    return Math.PI * Math.pow(this.radius, 2);
  };
}

// 인스턴스 생성
// 반지름이 1인 인스턴스 생성
const circle1 = new Circle(1);
// 반지름이 2인 인스턴스 생성
const circle2 = new Circle(2);

console.log(circle1.getArea === circle2.getArea); // false

console.log(circle1.getArea()); // 3.141592653589793
console.log(circle2.getArea()); // 12.566370614359172
```

- getArea 메소드는 동일한 코드이기 때문에 하나만 생성되어 모든 인스턴스가 공유하는것이 효율적이다.
- 하지만 생성자 함수를 통한 인스턴스 생성은, 생성할 때마다 getArea 메소드를 중복 소유한다.
- 일반적으로 메소드는 동일하게 10개이상 생성해야 할경우, 불필요하게 메모리를 낭비하고 퍼포먼스에 악영향을 준다.
- 프로토타입을 기반으로 상속을 구현하여 해결할 수 있다.

```
// 생성자 함수
function Circle(radius) {
  this.radius = radius;
}

Circle.prototype.getArea = function () {
  return Math.PI * Math.pow(this.radius, 2);
};

// 인스턴스 생성
const circle1 = new Circle(1);
const circle2 = new Circle(2);

console.log(circle1.getArea === circle2.getArea); // true

console.log(circle1.getArea()); // 3.141592653589793
console.log(circle2.getArea()); // 12.566370614359172
```

- Circle 생성자 함수가 생성한 모든 인스턴스가 공유할 수 있도록 getArea 메소드를 프로토타입에 추가한다.
- 프로토타입은 Circle 생성자 함수의 prototype 프토퍼티에 바인딩 되어 있다.
- Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는 프로토타입 Circle.prototype.getArea 메소드를 상속받는다.
- Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메소드를 공유한다.
- 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 미리 구현해 놓으면 생성자 함수가 생성할 모든 인스턴스는 별도의 구현없이 공유하여 사용할 수 있다.



### 프로토타입 객체

- 모든 객체는 [[Prototype]] 이라는 내부 슬롯을 갖는다.
- 모든 객체는 생성될 때 [[Prototype]] 내부 슬롯의 값으로 프로토타입의 참조를 저장한다.
- 모든 객체는 하나의 프로토타입을 갖으며, 프로토 타입은 객체 생성 방식에 의해 결정된다
- 프로토타입은 null이거나 객체이다.



####  1)  `__ proto__` : 접근자 프로퍼티

- 모든 객체는 접근자 프로퍼티를 통해 자신의 프로토타입, [[Prototype]] 내부 슬롯이 가리키는 객체에 접근할 수 있다.
- ![image-20191006231605139](/Users/igayeong/Library/Application Support/typora-user-images/image-20191006231605139.png)
- 프로토타입은 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있다.
- 생성자 함수는 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다.
- ![image-20191006232143422](/Users/igayeong/Library/Application Support/typora-user-images/image-20191006232143422.png)























```
객체 리터럴에 의해 생성된 객체의 프로토타입은 Object.prototype이고, 생성자 함수에 의해 생성된 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어있다.
```

![image-20191006224617972](/Users/igayeong/Library/Application Support/typora-user-images/image-20191006224617972.png)

```
// 내가 새롭게 안 사실!!!
1. this로 정의한 생성자함수 정의는 일반호출시 undefined로 console.dir로도 확인할 수 없다.
2. 인스턴스는 각각의 객체들이 독립적인 메모리를 갖느다. 즉 동일한 메소드더라도 각각 메모리를 소유한다.

// 생성자함수
생성자 함수는 생성자함수를 정의하여 인스턴스를 생성할 때 쓰이는데, 동일한 프로퍼티와 메소드를 정의한 후 인스턴스를 생성한다. 그런데 생성할 인스턴스는 무수히 많고 메소드는 동일할 때,이러한 방법은 메모리의 낭비이며 퍼포먼스가 떨어지는 상황으로 이어진다. 비효율적이다.
따라서 상속의 개념인 프로토타입을 활용하면, 이 상황을 해결할 수 있다.
방법은, 프로퍼티만을 생성자함수에 정의한후,부모객체라 할수있는 프로토타입에 메소드를 정의한다.
생성자함수를 통해 인스턴스를 생성한후,확인해보면 __proto__에서 프로토타입으로 할당한 메소드를 확인할 수 있다. 생성자 함수를 통해 생성된 인스턴스들은 메소드까지 알아서 상속받았다는것을 확인할 수 있다.
```

<질문>

1. 메소드뿐만 아니라 프로퍼티도 프로토타입에 생성하면 안되나요? 
=> 됩니당!!! 인스턴스를 생성한후에 프로퍼티를 추가해도, `__proto__`에서 프로토타입에 지정한 메소드와 프로퍼티 모두 확인할 수 있다, 이로써 프로토타입 또한 객체이며 메모저장 방식또한 객체와 동일하게 한 메모리를 레퍼런스 하며, 동적으로 추가가 가능하다.