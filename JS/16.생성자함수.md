## 생성자 함수

- 생성자함수란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다
- 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라 한다.
- 첫문자를 대문자로 기술하는 파스칼 케이스로 명명하여 일반함수와 구별할 수 있도록 한다.




> 인스턴스

생성자 함수도 객체이기 때문에 생성자 함수나 클래스가 생성한 객체를 다른 객체와 구분하기 위해 인스턴스라고 부른다.



>  자바스크립트가 제공하는 내장함수

- Object
- String
- Number
- Boolean
- Function
- Array
- Date
- RegExp



> this

1. 일반함수 호출  => 전역객체
2. 메소드 호출 => 메소드 호출한 객체
3. 생성자함수 호출 => 생성자함수가 생성할 인스턴스



### 객체 생성 방식 2가지

#### 1) 객체 리터럴

객체리터럴에 의한 객체생성방식은 1개의 객체만을 생성할 수 있다.

#### 2) 생성자 함수
- 일반함수와 동일한 방법으로 생성자함수를 정의하고 new연산자와 함께 호출하면 해당함수는 생성자함수로 동작한다.
- new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자함수가 아니라 일반함수로 동작한다.
- 생성자함수에서 this를 사용해 정의하였다면, 일반함수로 동작하게 됐을때 this가 가르키는것은 전역객체를 말한다.



### 내부 메소드
- 함수또한 객체이므로 일반객체와 동일하게 동작할 수 있다.
- 따라서 일반객체의 내부슬롯과 내부메소드를 모두 갖고 있다.



##### 내부메소드  [[ Call ]] 을 갖는  함수객체  `callable`
: 호출할 수 있는 객체, 즉 함수를 말한다.

##### - 내부메소드 [[Construct]]을 갖는 함수 객체를  `constructor`

: new연산자 또는 super연산자와 함께 생성자 함수로서 호출하는 객체를 의미한다.

##### - 내부메소드 [[Construct]]을 갖지 않는 함수 객체를  ` non-constructor`

```
function foo() {}

// 일반적인 함수호출 : 내부메소드[[Call]]이 호출된다.
foo();
// 생성자 함수로서 호출 : [[Construct]]가 호출된다.
new foo();
```



> super 키워드

ES6에서 도입된 클래스에서 부모 클래스를 참조할때 부모 클래스의 생성자를 호출할 때 사용한다.



- 모든 함수 객체는 내부 메소드 [[Call]]을 갖고 있기 때문에 호출할 수 있다.
- 모든 함수 객체가 [[Construct]]를 갖지는 않는다. 
- 모든 함수 객체는 호출할 수 있지만, 모든 함수객체가 생성자 함수로써 호출할 수 있는것은 아니다.

#### constructor와 non-constructor의 구분

| 구분                                                 | 함수의 종류는 나타내는 문자열 |
| ---------------------------------------------------- | ----------------------------- |
| 알반 함수 정의(함수 선언문, 함수 표현식)을 평가할 때 | Nomal                         |
| 화살표 함수 정의를 평가할 때                         | Arrow                         |
| 메소드 정의를 평가할 때                              | Method                        |

```
// 일반 함수 정의 : kind = 'Normal'
function foo() {}
const bar = function () {};
// 프로퍼티 x에 할당된 것은 일반 함수 정의이다. 메소드 정의로 인정하지 않는다.
const baz = {
  x: function () {}
};

// 일반 함수로 정의된 함수만이 constructor이다.
new foo(); // OK
new bar(); // OK
new baz.x(); // OK

// 화살표 함수 정의 : kind = 'Arrow'
const arrow = () => {};

new arrow(); // TypeError: arrow is not a constructor

// 메소드 정의 : kind = 'Method'
// ES6의 메소드 축약 표현만을 메소드 정의로 인정한다.
const obj = {
  x() {}
};

new obj.x(); // TypeError: obj.x is not a constructor
```

- 일반 함수로 정의돈 함수만이 `constructor`

- 화살표 함수나 ES6의 메소드 축약표현 메소드는 `non-constructor`



#### 생성자 함수의 인스턴스 생성 과정

- 생성자 함수의 목적은 동일한 프로퍼티를 가진 **인스턴스를 생성하기 위한** 템플릿(클래스)이다.
- 그리고 생성된 **인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)**하는 것이다.
- 인스턴스 생성은 필수이고, 초기화는 선택이다.



> 바인딩

바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 변수는 할당에 의해 값이 바인딩된다.



```
// 생성자 함수
function Circle(radius) {
  // 인스턴스 초기화
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// 인스턴스 생성
const circle1 = new Circle(5);  // 반지름이 5인 Circle 객체를 생성
-------------------------------------------------------------------
런타임에 new키워드와 생성자함수 템플릿이 할당되며,
표현식이 평가되고, circle1이라는 객체가 생성되었다.
circle1은 인스턴스가 되어 호출할 수 있다.
circle1(); 

템플릿 Circle과 Circle의 메소드는 호출할 수 없다.
Circle();, Circle(10);
=> undefined
Circle.getDiameter(); // TypeError, not a function
위 선언문을 변수에 할당해 보았다.
faith()
=> undefined
hello라는 기명함수로 함수선언문을 재정의하며, 안에 오직 매소드만 this방식을 버리고 일반 메소드 표현식방식으로 정의하고 호출했다.
hello.getDiameter(10) // TypeError, not a function


왜지?
1. this 방식으로 선언해서?
2. return문이 없어서?
=> return문이 없어서다!!!!
인수값을 넣든말든 그래서 undefined가 나온다.
this방식으로 인해 메소드는 호출할 수 없다.


- 콘솔창과 노드js환경의 차이
- 타입에러가 나오는 상황


```





2-5 


```
- 함수는 객체이다.
- 함수는 객체이기 때문에 프로퍼티를 소유할수 있다.
- 함수는 객체이기 때문에 메소드를 소유할수 있다.

함수는 호출할때 표현식이 평가되어 객체가 된다.

- 객체의 프로퍼티의 값으로도 함수가 올수 있다.
- lee 객체명을 치면, 객체의 프로퍼티가 나온다. (함수의 경우, 프로퍼티키와 function)
- lee.hello 프로터피명을 함께 검색하면, 메소드의 수식이 나온다.
- lee.hello() 메소드를 호출까지 해야 수식의 값이 나온다.
- 객체든, 함수든 마찬가지다.

__proto__: Object // 인스턴스
__proto__: f() // 생성자함수 템플릿

```





















참고문헌